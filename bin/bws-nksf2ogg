#!/usr/bin/env node

const fs = require('fs'),
      path = require('path'),
      execSync = require('child_process').execSync,
      program = require('commander'),
      updateNotifier = require('update-notifier'),
      rimraf = require('rimraf'),
      glob = require('glob'),
      Confirm = require('prompt-confirm'),
      ffmpeg = require('fluent-ffmpeg'),
      {Bar} = require('cli-progress'),
      chalk = require('chalk'),
      emoji = require('node-emoji'),
      nksf2ogg = require('../lib/bitwig-nks-preview-generator'),
      Local = require('../lib/bitwig-studio-local'),
      logger = require('../lib/logger'),
      log = logger('bws-nksf2ogg'),
      {PluginProcessingError, PluginDiscardFile} = require('../lib/gulp-plugin-wrapper'),
      pkg = require('../package.json'),
      notifier = updateNotifier({pkg}),
      defaults = nksf2ogg.defaultOptions,
      descs = nksf2ogg.optionsDescriptions;

if (notifier.update && notifier.update.latest !== pkg.version) {
  notifier.notify({
    defer: false
  });
}

program
  .description(pkg.description)
  .version(pkg.version);

program
  .command('exec <dir>')
  .description('Generate preview audio from .nksf preset files recursively.')
  .option('-d, --debug <level>',             'console verbosity level in testing, 0:none 1:ERROR 2:INFO 3:DEBUG 4:Bitwig Studio', intArg,  0)
  .option('-b, --bitwig <path>',             descs.bitwig,               defaults.bitwig)
  .option('-u, --url <URL>',                 descs.url,                  defaults.url)
  .option('-s, --skip-error',                descs.skipError)
  .option('-k, --skip-exist',                descs.skipExist)
  .option('-h, --show-plugin',               descs.showPlugin)
  .option('-c, --clip <path>',               descs.clip,                  defaults.clip)
  .option('-f, --fxb <path>',                descs.fxb,                   defaults.fxb)
  .option('-w, --wav <path>',                descs.wav,                   defaults.wav)
  .option('-t, --timeout <msec>',            descs.timeout,     msecArg, defaults.timeout)
  .option('-a, --wait-plugin <msec>',        descs.waitPlugin,  msecArg, defaults.waitPlugin)
  .option('-i, --wait-preset <msec>',        descs.waitPreset,  msecArg, defaults.waitPreset)
  .option('-e, --tempo <BPM>',               descs.tempo,       intArg,  defaults.tempo)
  .option('-f, --freq <Hz>',                 descs.freq,        intArg,  defaults.freq)
  .option('-d, --fadeout <samples>',         descs.fadeout,     intArg,  defaults.fadeout)
  .option('-l, --silence <dB>',              descs.silence,              defaults.silence)
  .option('-q, --quality <number>',          descs.quality,     intArg,  defaults.quality)
  .action(execCommand);

program
  .command('install')
  .description('Install Bitwig Studio WebSockets RPC server extension.')
  .option('-e, --extension-dir <path>', 'Bitwig Studio Extension directory', Local.defaultExtensionDir())
  .action(installCommand);

program
  .command('list <dir>')
  .description('List .nksf or .nksf.ogg files recursively.')
  .option('-a, --absolute', 'list files as absolute path', false)
  .option('-r, --relative', 'list files as relative path from <dir>', false)
  .option('-m, --missing',  "list preset files that doesn't have preview", false)
  .option('-u, --useless',  "list preview files that doesn't have preset", false)
  .option('-f, --ffprobe',  "list files as result of ffprobe", false)
  .action(listCommand);

program
  .command('clean <dir>')
  .description('Delete .previews folders recursively.')
  .option('-y, --yes', 'no comfirmation', false)
  .action(cleanCommand);

program.parse(process.argv);

function msecArg(val, def) {
  const v = parseInt(val);
  return v;
}

function intArg(val, def) {
  const v = parseInt(val);
  return v;
}

/**
 * install Bitwig Studio Extension.
 * @param {Object} options
 */
function installCommand(options) {
  _checkDir(options.extensionDir);
  const basename = 'WebSocketRpcServer.bwextension';
  const src = path.resolve(__dirname, '../node_modules/bitwig-websocket-rpc', basename);
  const dest = path.join(options.extensionDir, basename);
  _checkFile(src);
  fs.copyFileSync(src, dest);
  console.info('file:', dest);
  console.info('Installation completed successfully.');
}

/**
 * List .nksf or .nksf.ogg files
 * @param {String} dir
 * @param {Object} options
 */
function listCommand(dir, options) {
  _checkDir(dir);
  const pattern = options.missing ?
        `${dir}/**/*.nksf` :
        `${dir}/**/.previews/*.nksf.ogg`;
  const filter = options.missing ?
        _hasNotPreview :
        (options.useless ? _hasNotPreset : undefined);
  const files = _glob(pattern, filter);
  files.forEach(file => {
    if (options.absolute) {
      file = path.resolve(file);
    } else if (options.relative) {
      file = path.relative(dir, file);
    }
    if (options.ffprobe) {
      ffmpeg(file)
        .ffprobe(function(err, data) {
          console.info(data);
        });
    } else {
      console.info(file);
    }
    firstFile = false;
  });
}

/**
 * Delete .previews folders
 * @param {String} dir
 * @param {Object} options
 */
function cleanCommand(dir, options) {
  _checkDir(dir);
  const folders = _glob(`${dir}/**/.previews/`);
  if (!folders.length) {
    console.info('".previews" folders are not found.');
    return;
  }
  if (options.yes) {
    rimraf.sync(`${dir}/**/.previews`);
    return;
  }
  new Confirm(
    `Founded ${folders.length} folders. ` +
      'Are you sure to delete all the ".previews" folders ?'
  ).ask(ans => {
    if (ans) {
      rimraf.sync(`${dir}/**/.previews`);
    }
  });
}

/**
 * Generate preview audio from preset files
 * @param {String} dir
 * @param {Object} options
 */
function execCommand(dir, options) {
  _checkDir(dir);
  _checkFile(options.bitwig);
  _checkFile(options.clip);

  const clipExt = path.extname(options.clip);
  if (clipExt !== '.bwclip' && clipExt !== '.js') {
    console.error('error: unsupported --clip <path> option.');
    process.exit(1);
  }

  if (clipExt === '.js') {
    _checkJsFunction(options.clip);
  }

  const numFiles = _glob(`${dir}/**/*.nksf`, options.skipExist ? _hasNotPreview : undefined).length;
  if (!numFiles) {
    console.info('Target ".nksf" files are not found.');
    return;
  }
  // initialize logger
  var bar,fileCount = 0;
  if (options.debug) {
    logger.configure(options.debug);
  } else {
    // progress bar
    bar = new Bar({
      format: 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total} | {file}'
    });
    bar.start(numFiles, fileCount);
  }
  // start the progress bar with a total value of 200 and start value of 0
  
  const summary = {
    completed: [],
    failed: [],
    ignored: []
  };
  nksf2ogg(dir, options, function(err, file) {
    if (bar) {
      bar.update(++fileCount, {
        file: (err ? '❌' : '✔️') + file ? file.relative : ''
      });
    }
    if (err) {
      if (err instanceof PluginDiscardFile) {
        summary.ignored.push(err.srcFile.path);
      } else if (err instanceof PluginProcessingError) {
        summary.failed.push({
          file: err.file.path,
          causedBy: err.causedBy
        });
        if (err.stop) {
          summary.stopCausedBy =  err.causedBy;
        }
      } else {
        summary.stopCausedBy =  err;
        this.emit('end');
      }
    } else if (file) {
      summary.completed.push(file.path);
    } else {
    }
  }).on('end', ()=>{
    // stop progress bar.
    if (bar) bar.stop();
  });
  process.on('exit', ()=>{
    if (summary.stopCausedBy) {
      console.info(chalk.redBright.bold('Execution done with error:'),
                   summary.stopCausedBy);
      process.exit(1);
    }
    if (summary) {
      const results = [];
      results.push(chalk.greenBright(`${summary.completed.length} files suceeded`));
      if (summary.failed.length) {
        results.push(chalk.redBright(`${summary.failed.length} files failed`));
      }
      if (summary.ignored.length) {
        results.push(chalk.yellowBright(`${summary.ignored.length} files ignored`));
      }
      console.info(chalk.greenBright.bold('Execution completed with result:'),
                   results.join(', ') + '.');
    }
  });
}

function _checkDir(dir) {
  if (!fs.existsSync(dir)) {
    console.error(`error: no such directory, "${dir}"`);
    process.exit(1);
  }
  if (!fs.statSync(dir).isDirectory()) {
    console.error(`error: no such directory, "${dir}"`);
    process.exit(1);
  }
}

function _checkFile(file) {
  if (!fs.existsSync(file)) {
    console.error(`error: no such file, "${file}"`);
    process.exit(1);
  }
  if (!fs.statSync(file).isFile()) {
    console.error(`error: no such file, "${file}"`);
    process.exit(1);
  }
}

function _checkJsFunction(file) {
  let fn;
  try {
    fn = require(path.resolve(file));
  } catch (err) {
    console.info(err);
    process.exit(1);
  }
  if (typeof fn !== 'function') {
    console.error('error: --clip <path> .js file should export function');
    process.exit(1);
  }
}

function _glob(pattern, filter, options = {}) {
  let files = glob.sync(pattern, options);
  if (filter) {
    files = files.filter((f) =>{
      return filter(f);
    });
  }
  return files;
}

function _hasPreview(file) {
  const preview = path.join(path.dirname(file), '.previews', path.basename(file) + '.ogg');
  return fs.existsSync(preview);
}

function _hasNotPreview(file) {
  return !_hasPreview(file);
}

function _hasPreset(file) {
  const preset = path.resolve(path.dirname(file), '..', path.basename(file, '.ogg'));
  return fs.existsSync(preset);
}

function _hasNotPreset(file) {
  return !_hasPreset(file);
}
