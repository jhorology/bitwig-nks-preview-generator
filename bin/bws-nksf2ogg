#!/usr/bin/env node

const fs = require('fs');
const os = require('os');
const path = require('path');
const execSync = require('child_process').execSync;
const log = require('fancy-log');
const program = require('commander');
const updateNotifier = require('update-notifier');
const glob = require('glob');
const rimraf = require('rimraf');
const pkg = require('../package.json');
const nksf2ogg = require('../lib/bitwig-nks-preview-generator');
const Local = require('../lib/bitwig-studio-local');
const notifier = updateNotifier({pkg});
const defaultMIDIClip = path.resolve(__dirname, '../Bitwig Studio Files/NKS-Preview-Cmaj-Chord.bwclip');

if (notifier.update && notifier.update.latest !== pkg.version) {
    notifier.notify({
      defer: false
    });
}

program
  .description(pkg.description)
  .arguments('<targetDir>')
  .option('-x, --clean',                     'cleanup .prevews folder recusively. do not execute converter process.', false)
  .option('-b, --bitwig <path>',             'execution path of Bitwig Studio.', Local.defaultExecuteFile())
  .option('-u, --url <URL>',                 'WebSockets server URL.', 'ws://localhost:8887')
  .option('-c, --clip <path>',               'file path of .bwclip or .js mapper program.', defaultMIDIClip)
  .option('-f, --fxb <path>',                'folder path for store intermediate .fxb files.', 'temp/fxb')
  .option('-w, --wav <path>',                'folder path for store intermediate .wav files.', 'temp/wav')
  .option('-i, --timeout <msec>',            'timeout millis for launching Bitwig Studio.', parseInt, 30000)
  .option('-p, --wait-plugin <msec>',        'wait time for loading plugin.', parseInt, 5000)
  .option('-r, --wait-preset <msec>',        'wait time for loading .fxb preset.', parseInt, 1500)
  .option('-b, --wait-bounce <msec>',        'wait time for bouncing clip.', parseInt, 500)
  .option('-u, --wait-undo <msec>',          'wait time for undo bouncing clip.', parseInt, 500)
  .option('-m, --tempo <BPM>',               'BPM for bouncing clip.', parseInt, 120)
  .option('-f, --freq <Hz>',                 '.ogg audio sampling rate.', parseInt, 441000)
  .option('-o, --fadeout <samples>',         'number of samples for fadeout.', parseInt, 110250)
  .option('-r, --silence <dB>',              'threshold level for removing silnce from end.', '-90dB')
  .option('-q, --quality <number>',          'quality of ogg compression. 0-10.', parseInt, 5)
  .option('-v, --version', pkg.version, () => {
    console.log(pkg.version);
    process.exit(0);
  })
  .option('-V', '', () => {
    console.log(pkg.version);
    process.exit(0);
  })
  .parse(process.argv);

if (program.args.length === 0) {
  console.error('\nError: Unspecified target directory.\n');
  program.help();
  process.exit(1);
}

const targetDir = program.args[0];

if (!(fs.existsSync(targetDir) &&
      fs.statSync(targetDir).isDirectory())) {
  console.error("\nError: Target directory doesn't exist.\n");
  program.help();
  process.exit(1);
}

const clipExt = path.extname(program.clip);
if (clipExt !== '.bwclip' && clipExt !== '.js') {
  console.error('\nError: Unsupported clip option.\n');
  program.help();
  process.exit(1);
}
if (!(fs.existsSync(program.clip) &&
      fs.statSync(program.clip).isFile())) {
  console.error("\nError: Couldn't find file for --clip option.\n");
  program.help();
  process.exit(1);
}

if (!path.isAbsolute(program.clip)) {
  program.clip = path.resolve(program.clip);
}

if (clipExt === '.js') {
  try {
    const mapperDirname = path.dirname(program.clip);
    const userMapperFn = require(program.clip);
    if (typeof userMapperFn !== 'function') {
      throw new Error('Clip mapper .js should export function');
    }
    // wwrap user function to convert absolute path
    program.clip = (soundInfo) => {
      const result = userMapperFn(soundInfo);
      if (!path.isAbsolute(result)) {
        return path.resolve(mapperDirname, result);
      }
      return result;
    };
  } catch (err) {
    console.error('\nError:' + err.message + '\n');
    program.help();
    process.exit(1);
  }
}

// for debug
process.on('unhandledRejection', (reason, p) => {
  log.error('###### Unhandled Rejection at: Promise', p, 'reason:', reason);
});

if (program.clean) {
  rimraf.sync(`${targetDir}/**/.previews`);
} else {
  log('Start processing target diretroy:', targetDir);
  nksf2ogg(targetDir, program)
    .on('end', () => {
      log('Complete processing target diretroy:', targetDir);
    });
}
