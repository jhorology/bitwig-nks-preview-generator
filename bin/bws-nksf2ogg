#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const execSync = require('child_process').execSync;

const program = require('commander');
const updateNotifier = require('update-notifier');
const rimraf = require('rimraf');
const glob = require('glob');
const Confirm = require('prompt-confirm');
const nksf2ogg = require('../lib/bitwig-nks-preview-generator');
const Local = require('../lib/bitwig-studio-local');
const pkg = require('../package.json');
const notifier = updateNotifier({pkg});

if (notifier.update && notifier.update.latest !== pkg.version) {
  notifier.notify({
    defer: false
  });
}
const defaults = nksf2ogg.defaultOptions;
const descs = nksf2ogg.optionsDescriptions;

program
  .description(pkg.description)
  .version(pkg.version);

program
  .command('exec <dir>')
  .description('Generate preview audio from .nksf preset files.')
  .option('-b, --bitwig <path>',             descs.bitwig,      defaults.bitwig)
  .option('-u, --url <URL>',                 descs.url,         defaults.url)
  .option('-s, --skip-error',                descs.skipError)
  .option('-k, --skip-exist',                descs.skipExist)
  .option('-h, --show-plugin',               descs.showPlugin)
  .option('-c, --clip <path>',               descs.clip,        defaults.clip)
  .option('-f, --fxb <path>',                descs.fxb,         defaults.fxb)
  .option('-w, --wav <path>',                descs.wav,         defaults.wav)
  .option('-t, --timeout <msec>',            descs.timeout,     parseInt, defaults.timeout)
  .option('-w, --wait-plugin <msec>',        descs.waitPlugin,  parseInt, defaults.waitPlugin)
  .option('-a, --wait-preset <msec>',        descs.waitPreset,  parseInt, defaults.waitPreset)
  .option('-i, --wait-bounce <msec>',        descs.waitBounce,  parseInt, defaults.waitBounce)
  .option('-u, --wait-undo <msec>',          descs.waitUndo,    parseInt, defaults.waitUndo)
  .option('-e, --tempo <BPM>',               descs.tempo,       parseInt, defaults.tempo)
  .option('-f, --freq <Hz>',                 descs.freq,        parseInt, defaults.freq)
  .option('-d, --fadeout <samples>',         descs.fadeout,     parseInt, defaults.fadeout)
  .option('-l, --silence <dB>',              descs.silence,     parseInt, defaults.silence)
  .option('-q, --quality <number>',          descs.quality,     parseInt, defaults.quality)
  .action(execCommand);

program
  .command('install')
  .description('Install Bitwig Studio WebSockets RPC server extension.')
  .option('-e, --extension-dir <path>', 'Bitwig Studio Extension directory', Local.defaultExtensionDir())
  .action(installCommand);

program
  .command('list <dir>')
  .description('List .nksf or .nksf.ogg files.')
  .option('-a, --absolute', 'list files as absolute path', false)
  .option('-r, --relative', 'list files as relative path from <dir>', false)
  .option('-m, --missing',  "list preset files that doesn't have preview", false)
  .option('-u, --useless',  "list preview files that doesn't have preset", false)
  .action(listCommand);

program
  .command('clean <dir>')
  .description('Delete .previews folders.')
  .option('-y, --yes', 'no comfirmation', false)
  .action(cleanCommand);

program.parse(process.argv);

/**
 * install Bitwig Studio Extension.
 * @param {Object} options
 */
function installCommand(options) {
  _checkDir(options.extensionDir);
  const basename = 'WebSocketRpcServer.bwextension';
  const src = path.resolve(__dirname, '../node_modules/bitwig-websocket-rpc', basename);
  const dest = path.join(options.extensionDir, basename);
  _checkFile(src);
  fs.copyFileSync(src, dest);
  console.info('file:', dest);
  console.info('Installation completed successfully.');
}

/**
 * List .nksf or .nksf.ogg files
 * @param {String} dir
 * @param {Object} options
 */
function listCommand(dir, options) {
  _checkDir(dir);
  const pattern = options.missing ?
        `${dir}/**/*.nksf` :
        `${dir}/**/.previews/*.nksf.ogg`;
  const filter = options.missing ?
        _hasNotPreview :
        (options.useless ? _hasNotPreset : undefined);
  const files = _glob(pattern, filter);
  files.forEach(file => {
    if (options.absolute) {
      file = path.resolve(file);
    } else if (options.relative) {
      file = path.relative(dir, file);
    }
    console.info(file);
  });
}

/**
 * Delete .previews folders
 * @param {String} dir
 * @param {Object} options
 */
function cleanCommand(dir, options) {
  _checkDir(dir);
  const folders = _glob(`${dir}/**/.previews/`);
  if (!folders.length) {
    console.info('".previews" folders are not found.');
    return;
  }
  if (options.yes) {
    rimraf.sync(`${dir}/**/.previews`);
    return;
  }
  new Confirm(
    `Founded ${folders.length} folders. ` +
      'Are you sure to delete all the ".previews" folders ?'
  ).ask(ans => {
    if (ans) {
      rimraf.sync(`${dir}/**/.previews`);
    }      
  });
}

/**
 * Generate preview audio from preset files
 * @param {String} dir
 * @param {Object} options
 */
function execCommand(dir, options) {
  _checkDir(dir);
  _checkFile(options.bitwig);
  _checkFile(options.clip);
  
  const clipExt = path.extname(options.clip);
  if (clipExt !== '.bwclip' && clipExt !== '.js') {
    console.error('error: unsupported --clip <path> option.');
    process.exit(1);
  }
  
  if (clipExt === '.js') {
    _checkJsFunction(options.clip);
  }

  const files = _glob(`${dir}/**/*.nksf`,
                      options.skipExist ? _hasNotPreview : undefined);

  if (!files.length) {
    console.info('Target ".nksf" files are not found.');
    return;
  }
  
  // for debug
  // process.on('unhandledRejection', (reason, p) => {
  //   console.log('###### Unhandled Rejection at: Promise', p, 'reason:', reason);
  // });

  nksf2ogg(dir, options, files.length, function(err, summary) {
    if (err) {
      console.error(err);
      process.exitt(1);
    }
    console.info('Execution completed successfully. resilt summary:', summary);
  });
}

function _checkDir(dir) {
  if (!fs.existsSync(dir)) {
    console.error(`error: no such directory, "${dir}"`);
    process.exit(1);
  }
  if (!fs.statSync(dir).isDirectory()) {
    console.error(`error: no such directory, "${dir}"`);
    process.exit(1);
  }
}

function _checkFile(file) {
  if (!fs.existsSync(file)) {
    console.error(`error: no such file, "${file}"`);
    process.exit(1);
  }
  if (!fs.statSync(file).isFile()) {
    console.error(`error: no such file, "${file}"`);
    process.exit(1);
  }
}

function _checkJsFunction(file) {
  let fn;
  try {
    fn = require(path.resolve(file));
  } catch (err) {
    console.info(err);
    process.exit(1);
  }
  if (typeof fn !== 'function') {
    console.error('error: --clip <path> .js file should export function');
    process.exit(1);
  }
}

function _glob(pattern, filter) {
  let files = glob.sync(pattern);
  if (filter) {
    files = files.filter(filter);
  }
  return files;
}

function _hasPreview(file) {
  const preview = path.join(path.dirname(file), '.previews', path.basename(file) + '.ogg');
  return fs.existsSync(preview);
}

function _hasNotPreview(file) {
  return !_hasPreview(file);

}

function _hasPreset(file) {
  const preset = path.resolve(path.dirname(file), '..', path.basename(file, '.ogg'));
  return fs.existsSync(preset);
}

function _hasNotPreset(file) {
  return !_hasPreset();
}

